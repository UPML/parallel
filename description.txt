Собственно, что я не объяснил.
При старте запускаем менеджера, который раздает границы поля для других потоков и подвисаем пока он не закончит с этим
на Conditional Variable.
Менеджер запускается, делит поле для потоков, определяет, кто чей сосед и запускает сколько указано потоков, которые будут,
обсчитывать само поле.
Каждый поток запустившись натыкается на
while(manager->wakeWhenNextIterationNeeded(myShared.iterationPublished)), и повисает на conditional variable.
После того, как все повисли, дальше работает менеджер.
Он изменяет своё состояние на STOPPED и повисает на Conditional variable и ждет, пока не изменится один из флагов его работы.
И соответственно обрабатывает события, когда флаги изменяются.
Далее начнет работать поток читающий из консоли отвиснув после того, как менеджер изменил свое состояние.
Он прочитает команду (рассмотрим на примере Run тк это самый интересный пример) например run 10,
в результате он запустит команду менеджера runForMore() которая изменит один из флагов, добавит количество итераций и разбудит
Conditional Variable на которой висел менеджер.
После этого менеджер проснется обновит свое состояние и разбудит всех воркеров.
Воркер проснется и поймет что ему нужно делать итерацию.

Как работает воркер.
Он ждет пока итерация будет нужна (висит на conditional variables и ждет пока его не разбудят).
что из себя представляет этот вызов
bool ThreadManagerShared::wakeWhenNextIterationNeeded(int have) {
    MutexLocker locker(stopMutex);
    if (stop != -1 && stop <= have) {  //здесь stop - количество сделанных итераций have то сколько нужно итераций.
                                     (если не успели доработать до нового вызова run, то складываются)
        incWorkersWaiting();    //здесь увеличиваем счетчик ожидающих процессов и в случае, если это был последний поток
        то он обновляет состояние менеджера и будит его.
        while (stop != -1 && stop <= have) {
            Cond &cond = stopCond;
            cond.wait(stopMutex);
        }
        decWorkersWaiting();
    }
    return stop != -1;
}

Потом он запускается и работает следующим образом.
сначала обсчитывает часть поля, которая не зависит от соседей. Потом ждет пока соседи опубликуют предыдущую версию
(тк она ему нужна чтобы посчитать границы) Считает границы, говорит всем, что он их посчитал, ждет пока соседи посчитают границы
и публикует свою новую версию поля. Потом говорит что он ее опубликавал и ждет пока менеджер не попросит его сделать ещё итерацию.
Здесь связь тоже сделана на conditional variable, потоки спят пока не досчитается поток которого они ждут.